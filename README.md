Zabbix Ruby Client
====================

[![Code Climate](https://codeclimate.com/github/eduvo/zabbix-ruby-client.png)](https://codeclimate.com/github/eduvo/zabbix-ruby-client)

This tool is designed to make easy to install zabbix reporter on monitored servers using zabbix-sender rather than zabbix-agent. It targets on monitoring mainly linux servers and is built on a plugin system so that you can decide what is going to be reported.

The development is still in progress but it produces results and works in my case. Use at your own risk and read the code first. It is developed under ruby 2 but should work on 1.9.3 as well.

Check the [Changelog](CHANGELOG.md) for recent changes, code is still under huge development and is likely to move a lot until version 0.1.

## Installation

Install it yourself as:

    gem install zabbix-ruby-client

## Usage

    zrc init [name]
    # will create a directory [name] (default: zabbix-ruby-client) for
    # storing configuration and temporary files

    cd [name]
    bundle
    # makes the zabbix-ruby-client [name] ready to run
    # then edit config.yml according to your needs

    bundle exec zrc
    # to list available commands

    bundle exec zrc show
    # to test the data collection

## Setting up cronjobs

When ready just install a cron task according to your environment

    echo '* * * * * /bin/bash -lc "cd /path/to/zrc && bundle exec zrc upload"' | crontab
    # or
    echo '* * * * * /bin/zsh -c ". $HOME/.rvm/scripts/rvm && cd /path/to/zrc && bundle exec zrc upload"' | crontab
    # or
    echo '* * * * * /bin/zsh -c "export RBENV_ROOT=/usr/local/var/rbenv && eval \"$(rbenv init - zsh)\" && cd /path/to/zrc && bundle exec zrc upload"' | crontab

By default `zrc show` and `zrc upload` will read config.yml (for the general config) and minutely.yml (for the list of plugins to run).

You can use -c to specify another config file, and -t to use another list of plugins. The `zrc init` command will create sample minutely.yml, hourly.yml and monthly.yml but you can create any arbitrary list of plugins, that can be used in your cronjobs.

Here is an example setup using the files generated by the init:

    * * * * * /bin/zsh -c ". $HOME/.rvm/scripts/rvm && cd $HOME/zrc && bundle exec zrc upload"
    0 0/6 * * * /bin/zsh -c ". $HOME/.rvm/scripts/rvm && cd $HOME/zrc && bundle exec zrc upload -t hourly.yml"
    0 0 1 * * /bin/zsh -c ". $HOME/.rvm/scripts/rvm && cd $HOME/zrc && bundle exec zrc upload -t monthly.yml"

## plugins

There are a set of standart plugins included in the package, aimed at linux systems.

* ubuntu system stats ([system_tpl](master/zabbix-templates/system_tpl.xml) includes the following)
  * load (uses /proc/loadavg) [load_tpl](master/zabbix-templates/load_tpl.xml)
  * cpu (uses /proc/stat) [cpu_tpl](master/zabbix-templates/cpu_tpl.xml)
  * memory (requires iostat, apt-get install sysstat) [memory_tpl](master/zabbix-templates/memory_tpl.xml)
  * disk (uses /proc/diskstats) [disk_tpl](master/zabbix-templates/disk_tpl.xml)
  * network (uses /proc/net/dev) [network_tpl](master/zabbix-templates/network_tpl.xml)
  * apt (uses ubuntu /usr/lib/update-notifier/apt-check) this one will populate the 'tag' field in host info, and is supposed to run every few hours or at least not every minute [apt_tpl](master/zabbix-templates/apt_tpl.xml)
  * sysinfo (uses uname -a) is populating the host info in the inventory, and should be ran at setup and/or monthly [sysinfo_tpl](master/zabbix-templates/sysinfo_tpl.xml)
* apache (depends on mod_status with status_extended on) [apache_tpl](master/zabbix-templates/apache_tpl.xml)

You can add extra plugin directories in the configuration file.

## Todo

* read /proc rather than rely on installed tools
* write tests
* add more plugins
  * memcache
  * redis
  * mysql master/slave
  * monit
  * passenger
  * nginx
  * logged users
  * denyhosts
  * postfix
  * sendgrid
  * airbrake
  * disk occupation (done)
* try to work out a way to create host/graphs/alerts from the client using Zabbix API
* verify compatibility with ruby 1.9


## Contributing

1. Fork it
2. Create your feature branch (`git checkout -b my-new-feature`)
3. Commit your changes (`git commit -am 'Add some feature'`)
4. Push to the branch (`git push origin my-new-feature`)
5. Create new Pull Request

## Contributors

* [@mose](https://github.com/mose) - author

## License

Copyright 2013 [Faria Systems](http://faria.co) - MIT license - created by mose at mose.com
